{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kitab - Book Recommendation System","text":""},{"location":"#package-overview","title":"Package Overview","text":"<p>The Kitab package aims to help bookstores with an easy-to-use recommendation system. When a customer requests a book that is currently unavailable, the system will utilize machine learning techniques to find similar books based on attributes such as genre, author, and book description. This will help bookstores enhance customer satisfaction and increase sales by offering relevant alternatives.</p>"},{"location":"#package-name","title":"Package Name","text":"<p>The package name is Kitab, which is the word for book in Arabic, Swahili, Urdu, Hindi and various Indian and Turkic languages.</p>"},{"location":"#contributors","title":"Contributors","text":"<p>The package was created as the final project of the DS 223 Marketing Analytics class at the American University of Armenia (AUA) during the Spring 2024 semester. The team members are:</p> <ul> <li>Alexander Shahramanyan</li> <li>Anna Charchyan</li> <li>Yeva Manukyan</li> <li>Lilith Asminian</li> <li>Maria Petrosyan</li> </ul> <p>The instructor of the course is Professor Karen Hovhannisyan. He oversaw the project and provided guidance to the team throughout the semester.</p>"},{"location":"additional/","title":"Database Schema","text":""},{"location":"additional/#overview","title":"Overview","text":"<p>The package also has some additional utilities which do not fall under other categories. These utilities are used to interact with the database and perform other operations:</p>"},{"location":"additional/#kitab.utils","title":"<code>kitab.utils</code>","text":"<p>This module contains utility functions for processing data and generating embeddings.</p>"},{"location":"additional/#kitab.utils.cos_mat_vec","title":"<code>cos_mat_vec(matr, vect)</code>","text":"<p>Compute the cosine similarity between a matrix (consisting of vectors) and a vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.utils import cos_mat_vec\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; vector = np.array([1, 2, 3])\n&gt;&gt;&gt; cos_mat_vec(matrix, vector)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>matr</code> <code>ndarray</code> <p>The matrix (containing individual vectors).</p> required <code>vect</code> <code>ndarray</code> <p>The vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The cosine similarity between the matrix and the vector.</p> Source code in <code>kitab\\utils.py</code> <pre><code>def cos_mat_vec(matr: np.ndarray, vect: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the cosine similarity between a matrix (consisting of vectors) and a vector.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.utils import cos_mat_vec\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        &gt;&gt;&gt; vector = np.array([1, 2, 3])\n        &gt;&gt;&gt; cos_mat_vec(matrix, vector)\n\n    Parameters:\n        matr (np.ndarray): The matrix (containing individual vectors).\n        vect (np.ndarray): The vector.\n\n    Returns:\n        np.ndarray: The cosine similarity between the matrix and the vector.\n    \"\"\"\n    dot_product = np.dot(matr, vect)\n    norm_vector1 = np.linalg.norm(matr, axis=1)\n    norm_vector2 = np.linalg.norm(vect)\n    return dot_product / (norm_vector1 * norm_vector2)\n</code></pre>"},{"location":"additional/#kitab.utils.cos_vec_vec","title":"<code>cos_vec_vec(vector1, vector2)</code>","text":"<p>Compute the cosine similarity between two vectors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.utils import cos_vec_vec\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; vector1 = np.array([1, 2, 3])\n&gt;&gt;&gt; vector2 = np.array([1, 2, 3])\n&gt;&gt;&gt; cos_vec_vec(vector1, vector2)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>vector1</code> <code>ndarray</code> <p>The first vector.</p> required <code>vector2</code> <code>ndarray</code> <p>The second vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The cosine similarity between the two vectors.</p> Source code in <code>kitab\\utils.py</code> <pre><code>def cos_vec_vec(vector1: np.ndarray, vector2: np.ndarray) -&gt; float:\n    \"\"\"\n    Compute the cosine similarity between two vectors.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.utils import cos_vec_vec\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; vector1 = np.array([1, 2, 3])\n        &gt;&gt;&gt; vector2 = np.array([1, 2, 3])\n        &gt;&gt;&gt; cos_vec_vec(vector1, vector2)\n\n    Parameters:\n        vector1 (np.ndarray): The first vector.\n        vector2 (np.ndarray): The second vector.\n\n    Returns:\n        float: The cosine similarity between the two vectors.\n    \"\"\"\n    dot_product = np.dot(vector1, vector2)\n    norm_vector1 = np.linalg.norm(vector1)\n    norm_vector2 = np.linalg.norm(vector2)\n    return dot_product / (norm_vector1 * norm_vector2)\n</code></pre>"},{"location":"additional/#kitab.utils.get_embedding","title":"<code>get_embedding(text)</code>","text":"<p>Returns the embedding of the text.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.utils import get_embedding\n&gt;&gt;&gt; get_embedding(text=\"Hello, world!\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to be embedded.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The embedding of the text.</p> Source code in <code>kitab\\utils.py</code> <pre><code>def get_embedding(text: str) -&gt; np.ndarray:\n    \"\"\"\n    Returns the embedding of the text.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.utils import get_embedding\n        &gt;&gt;&gt; get_embedding(text=\"Hello, world!\")\n\n    Parameters:\n        text (str): The text to be embedded.\n\n    Returns:\n        np.ndarray: The embedding of the text.\n    \"\"\"\n    return model.encode(text)    \n</code></pre>"},{"location":"additional/#kitab.utils.process_data","title":"<code>process_data(data_file, destination_folder='data', column_names=None, random_availability=False, chunk_size=20000, verbose=False)</code>","text":"<p>Process the given data file, perform data cleaning, and save the processed data and embeddings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.utils import process_data\n&gt;&gt;&gt; process_data(data_file=\"data.csv\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data_file</code> <code>str</code> <p>The path to the data file.</p> required <code>destination_folder</code> <code>str</code> <p>The path to the destination folder where the processed data and embeddings will be saved.</p> <code>'data'</code> <code>column_names</code> <code>dict[str</code> <p>str], optional): A dictionary mapping required column names to the corresponding column names in the data file. Defaults to None.</p> <code>None</code> <code>random_availability</code> <code>bool</code> <p>If True, add random book availability to the data. If False, the data must contain an 'availability' column. Defaults to False.</p> <code>False</code> <code>chunk_size</code> <code>int</code> <p>The size of the chunks to split the data into. Defaults to 20000.</p> <code>20000</code> <code>verbose</code> <code>bool</code> <p>If True, display log messages. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\utils.py</code> <pre><code>def process_data(data_file: str, destination_folder: str = \"data\", column_names: dict[str:str] = None, random_availability: bool = False, chunk_size: int = 20000, verbose: bool = False) -&gt; None:\n    \"\"\"\n    Process the given data file, perform data cleaning, and save the processed data and embeddings.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.utils import process_data\n        &gt;&gt;&gt; process_data(data_file=\"data.csv\")\n\n    Parameters:\n        data_file (str): The path to the data file.\n        destination_folder (str): The path to the destination folder where the processed data and embeddings will be saved.\n        column_names (dict[str:str], optional): A dictionary mapping required column names to the corresponding column names in the data file. Defaults to None.\n        random_availability (bool, optional): If True, add random book availability to the data. If False, the data must contain an 'availability' column. Defaults to False.\n        chunk_size (int, optional): The size of the chunks to split the data into. Defaults to 20000.\n        verbose (bool, optional): If True, display log messages. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    # Check the destination folder\n    if not os.path.exists(destination_folder):\n        os.makedirs(destination_folder)\n    elif os.listdir(destination_folder):\n        raise Exception(f\"Folder '{destination_folder}' is not empty.\")\n\n    # Load the data\n    data = pd.read_csv(data_file)\n\n    if verbose:\n        logger.info(\"Data loaded successfully.\")\n\n    # Make sure all required columns present\n    for req_col in REQUIRED_COLUMNS:\n        if (column_names and column_names[req_col] not in data.columns) or req_col not in data.columns:\n                raise Exception(f\"{req_col} column required, but missing in the given data.\")\n\n    if random_availability:\n        # Add random book available\n        np.random.seed(42)\n        data['available'] = np.random.choice([True, False], size=len(data), p=[0.3, 0.7])\n        if verbose:\n            logger.info(\"Available column added.\")\n    elif (column_names and column_names[\"available\"] not in data.columns) or \"available\" not in data.columns:\n        raise Exception(\"available column required, but missing in the given data. Either add it, or set random_availability to True.\")\n\n    if verbose:\n        logger.info(\"All columns available.\")\n\n    # Rename the columns to the default column names\n    if column_names:\n        reverse_mapping = {v: k for k, v in column_names.items()}\n        data.rename(columns=reverse_mapping, inplace=True)\n\n    # Keep only the required columns\n    data = data[REQUIRED_COLUMNS + [\"available\"]]\n\n    # TODO data cleaning here, you need to be able to explain what you did and why\n    # Drop NA descriptions\n    data = data.dropna(subset=[\"description\"])\n\n    split_len = chunk_size\n    split_data = [data[idx*split_len:(idx+1)*split_len] for idx in range(math.ceil(len(data)/split_len))]\n\n    if verbose:\n        logger.info(\"Starting computing the embeddings.\")\n    for idx, d_part in tqdm(enumerate(split_data)):          \n        # Save the d_part as a CSV\n        d_part.to_csv(f\"{destination_folder}/data_{idx}.csv\", index=False)\n\n        # Generate embeddings for the cleaned descriptions\n        embeddings = model.encode(d_part[\"description\"].tolist())\n\n        # Save the embeddings as a pickle file\n        with open(f'{destination_folder}/embeddings_{idx}.pkl', 'wb') as f:\n            pkl.dump(embeddings, f)\n</code></pre>"},{"location":"additional/#kitab.logger.logger","title":"<code>kitab.logger.logger</code>","text":"<p>This module contains the custom formatter for logging messages.</p>"},{"location":"additional/#kitab.logger.logger.CustomFormatter","title":"<code>CustomFormatter</code>","text":"<p>             Bases: <code>Formatter</code></p> <p>Custom formatter for logging</p> <p>This class provides a custom formatter for logging messages. It defines different color codes for different log levels and formats the log messages accordingly.</p> Source code in <code>kitab\\logger\\logger.py</code> <pre><code>class CustomFormatter(logging.Formatter):\n    \"\"\" \n    Custom formatter for logging\n\n    This class provides a custom formatter for logging messages. It defines different color codes for different log levels and formats the log messages accordingly.\n    \"\"\"\n\n    grey = \"\\x1b[38;20m\"\n    violet=\"\\x1b[38;5;183m\"\n    yellow = \"\\x1b[33;20m\"\n    red = \"\\x1b[31;20m\"\n    bold_red = \"\\x1b[31;1m\"\n    reset = \"\\x1b[0m\"\n    format = \"%(asctime)s - %(name)s - %(funcName)s - %(levelname)s - (%(message)s) - line: %(lineno)d\"\n    FORMATS = {\n        logging.DEBUG: grey + format + reset,\n        logging.INFO: violet + format + reset,\n        logging.WARNING: yellow + format + reset,\n        logging.ERROR: red + format + reset,\n        logging.CRITICAL: bold_red + format + reset\n    }\n\n    def format(self, record):\n        \"\"\"\n        Format the log record with colored output.\n\n        Parameters:\n        record (logging.LogRecord): The log record to be formatted.\n\n        Returns:\n        str: The formatted log message with colored output.\n        \"\"\"\n        log_fmt = self.FORMATS.get(record.levelno)\n        formatter = logging.Formatter(log_fmt)\n        return formatter.format(record)\n</code></pre>"},{"location":"additional/#kitab.logger.logger.CustomFormatter.format","title":"<code>format(record)</code>","text":"<p>Format the log record with colored output.</p> <p>Parameters: record (logging.LogRecord): The log record to be formatted.</p> <p>Returns: str: The formatted log message with colored output.</p> Source code in <code>kitab\\logger\\logger.py</code> <pre><code>def format(self, record):\n    \"\"\"\n    Format the log record with colored output.\n\n    Parameters:\n    record (logging.LogRecord): The log record to be formatted.\n\n    Returns:\n    str: The formatted log message with colored output.\n    \"\"\"\n    log_fmt = self.FORMATS.get(record.levelno)\n    formatter = logging.Formatter(log_fmt)\n    return formatter.format(record)\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#run-the-server","title":"Run the server","text":"<p>The package also provides API functionality to interact with the recommendation model. To run the server, you need to run the <code>run.py</code> file:</p> <pre><code>python run.py\n</code></pre>"},{"location":"api/#kitab.api.app","title":"<code>kitab.api.app</code>","text":"<p>This module contains the API for the book recommendation system.</p>"},{"location":"api/#kitab.api.app.add_book","title":"<code>add_book(book)</code>","text":"<p>Add a book to the database.</p> <p>Parameters: book (dict): The book information.</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>@app.post(\"/add_book\")\ndef add_book(book: Book):\n    \"\"\"\n    Add a book to the database.\n\n    Parameters:\n    book (dict): The book information.\n    \"\"\"\n    # Get the book as a dictionary\n    book = book.model_dump(exclude_unset=True)\n\n    # Check if the book is in the database\n    if get_book_by_ISBN(book[\"isbn\"]) is not None:\n        return {\"message\": \"Book already exists. Use /update_book to update the book.\"}\n\n    # If book isn't in the database, add it\n    if add_book_db(book):\n        return {\"message\": \"Book added successfully\"}\n\n    return {\"message\": \"Something went wrong. Book not added.\"}\n</code></pre>"},{"location":"api/#kitab.api.app.add_log","title":"<code>add_log(description, recommendation_isbn, successful)</code>","text":"<p>Add a log of a recommendation.</p> <p>Parameters: description (str): The description of the book. recommendation_isbn (str): The ISBN of the recommended book. successful (bool): Whether the recommendation was successful.</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>@app.post(\"/add_log\")\ndef add_log(description: str, recommendation_isbn: str, successful: bool):\n    \"\"\"\n    Add a log of a recommendation.\n\n    Parameters:\n    description (str): The description of the book.\n    recommendation_isbn (str): The ISBN of the recommended book.\n    successful (bool): Whether the recommendation was successful.\n    \"\"\"        \n    # Check if the book is in the database\n    if get_book_by_ISBN(recommendation_isbn) is None:\n        return {\"message\": \"No book with the given ISBN in the database.\"}\n\n    # If book isn't in the database, add it\n    if add_recommendation_log(description, recommendation_isbn, successful):\n        return {\"message\": \"Log successfully added.\"}\n\n    return {\"message\": \"Something went wrong. Log not added.\"}\n</code></pre>"},{"location":"api/#kitab.api.app.get_book_isbn","title":"<code>get_book_isbn(isbn)</code>","text":"<p>Get the book by ISBN.</p> <p>Parameters: ISBN (str): The ISBN of the book.</p> <p>Returns: dict: The book information.</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>@app.get(\"/get_book_by_isbn\")\ndef get_book_isbn(isbn: str):\n    \"\"\"\n    Get the book by ISBN.\n\n    Parameters:\n    ISBN (str): The ISBN of the book.\n\n    Returns:\n    dict: The book information.\n    \"\"\"\n    # Get the book by ISBN\n    book = get_book_by_ISBN(isbn)\n\n    # If it doesn't exist, return a message\n    if book is None:\n        return {\"message\": \"Book not found.\"}\n\n    return book\n</code></pre>"},{"location":"api/#kitab.api.app.get_book_title","title":"<code>get_book_title(title)</code>","text":"<p>Get the book by title.</p> <p>Parameters: title (str): The title of the book.</p> <p>Returns: dict: The book information.</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>@app.get(\"/get_book_by_title\")\ndef get_book_title(title: str):\n    \"\"\"\n    Get the book by title.\n\n    Parameters:\n    title (str): The title of the book.\n\n    Returns:\n    dict: The book information.\n    \"\"\"\n    # Get the book by ISBN\n    book = get_book_by_title(title)\n\n    # If it doesn't exist, return a message\n    if book is None:\n        return {\"message\": \"Book not found.\"}\n\n    return book\n</code></pre>"},{"location":"api/#kitab.api.app.get_logs","title":"<code>get_logs(recommendation_isbn)</code>","text":"<p>Return the history of recommendations for the book with the given ISBN.</p> <p>Parameters: recommendation_isbn (str): The ISBN of the book.</p> <p>Returns: dict: The history of recommendations.</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>@app.get(\"/get_logs\")\ndef get_logs(recommendation_isbn: str):\n    \"\"\"\n    Return the history of recommendations for the book with the given ISBN.\n\n    Parameters:\n    recommendation_isbn (str): The ISBN of the book.\n\n    Returns:\n    dict: The history of recommendations.\n    \"\"\"\n    # Check if the book is in the database\n    if get_book_by_ISBN(recommendation_isbn) is None:\n        return {\"message\": \"No book with the given ISBN in the database.\"}\n\n    return get_history_by_recommendation_isbn(recommendation_isbn)\n</code></pre>"},{"location":"api/#kitab.api.app.get_recommendations","title":"<code>get_recommendations(description, n, get_available=True)</code>","text":"<p>Return n book recommendations based on the description.</p> <p>Parameters: description (str): The description of the book. n (int): The number of recommendations to return. get_available (bool, optional): Whether to only recommend available books. Defaults to True.</p> <p>Returns: dict: The recommendations.</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>@app.get(\"/get_recommendations\")\ndef get_recommendations(description: str, n: int, get_available: bool = True):\n    \"\"\"\n    Return n book recommendations based on the description.\n\n    Parameters:\n    description (str): The description of the book.\n    n (int): The number of recommendations to return.\n    get_available (bool, optional): Whether to only recommend available books. Defaults to True.\n\n    Returns:\n    dict: The recommendations.\n    \"\"\"\n    # Get the recommendations\n    books = recommend_books(description=description, n=n, get_available=get_available)\n\n    return books\n</code></pre>"},{"location":"api/#kitab.api.app.get_recommendations_by_isbn","title":"<code>get_recommendations_by_isbn(isbn, n, get_available=True)</code>","text":"<p>Return n book recommendations based on recommendation of the book with the given ISBN.</p> <p>Parameters: ISBN (str): The ISBN of the book. n (int): The number of recommendations to return. get_available (bool, optional): Whether to only recommend available books. Defaults to True.</p> <p>Returns: dict: The recommendations.</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>@app.get(\"/get_recommendations_by_isbn\")\ndef get_recommendations_by_isbn(isbn: str, n: int, get_available: bool = True):\n    \"\"\"\n    Return n book recommendations based on recommendation of the book with the given ISBN.\n\n    Parameters:\n    ISBN (str): The ISBN of the book.\n    n (int): The number of recommendations to return.\n    get_available (bool, optional): Whether to only recommend available books. Defaults to True.\n\n    Returns:\n    dict: The recommendations.\n    \"\"\"\n    # Check if the book exists in the database\n    if get_book_by_ISBN(isbn) is None:\n        return {\"message\": \"Book does not exist. Please use /get_recommendations or /get_recommendations_by_title.\"}\n\n    # Get the recommendations\n    books = recommend_books_by_ISBN(ISBN=isbn, n=n, get_available=get_available)\n\n    return books\n</code></pre>"},{"location":"api/#kitab.api.app.get_recommendations_by_title","title":"<code>get_recommendations_by_title(title, n, get_available=True)</code>","text":"<p>Return n book recommendations based on recommendation of the book with the given title.</p> <p>Parameters: title (str): The title of the book. n (int): The number of recommendations to return. get_available (bool, optional): Whether to only recommend available books. Defaults to True.</p> <p>Returns: dict: The recommendations.</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>@app.get(\"/get_recommendations_by_title\")\ndef get_recommendations_by_title(title: str, n: int, get_available: bool = True):\n    \"\"\"\n    Return n book recommendations based on recommendation of the book with the given title.\n\n    Parameters:\n    title (str): The title of the book.\n    n (int): The number of recommendations to return.\n    get_available (bool, optional): Whether to only recommend available books. Defaults to True.\n\n    Returns:\n    dict: The recommendations.\n    \"\"\"\n    # Check if the book exists in the database\n    if get_book_by_title(title) is None:\n        return {\"message\": \"Book does not exist. Please use /get_recommendations or /get_recommendations_by_isbn.\"}\n\n    # Get the recommendations\n    books = recommend_books_by_title(title=title, n=n, get_available=get_available)\n\n    return books\n</code></pre>"},{"location":"api/#kitab.api.app.run_api","title":"<code>run_api(port=5552)</code>","text":"<p>Run the API server.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.utils import run_api\n&gt;&gt;&gt; run_api(port=5552)\n</code></pre> <p>Parameters: port (int): The port number on which the API server will run.</p> <p>Returns: None</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>def run_api(port=5552) -&gt; None:\n    \"\"\"\n    Run the API server.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.utils import run_api\n        &gt;&gt;&gt; run_api(port=5552)\n\n    Parameters:\n    port (int): The port number on which the API server will run.\n\n    Returns:\n    None\n    \"\"\"\n    uvicorn.run(app, port=port) \n</code></pre>"},{"location":"api/#kitab.api.app.update_book","title":"<code>update_book(isbn, new_book)</code>","text":"<p>Update a book in the database.</p> <p>Parameters: ISBNs (str): The ISBN of the book. new_book (dict): The new book information.</p> Source code in <code>kitab\\api\\app.py</code> <pre><code>@app.put(\"/update_book\")\ndef update_book(isbn: str, new_book: BookUpdate):\n    \"\"\"\n    Update a book in the database.\n\n    Parameters:\n    ISBNs (str): The ISBN of the book.\n    new_book (dict): The new book information.\n    \"\"\"\n    # If book isn't in the database, return a message\n    if get_book_by_ISBN(isbn) is None:\n        return {\"message\": \"Book does not exist. Use /add_book to add the book.\"}\n\n    # Get the set fields\n    set_fields = new_book.model_dump(exclude_unset=True)\n\n    # If no fields have been set, return a message\n    if len(set_fields.keys()) == 0:\n        return {\"message\": \"Nothing passed.\"}\n\n    # Compare the old book with the new one\n    new_book = new_book.model_dump()\n    old_book= get_book_by_ISBN(isbn)\n\n    # Remove unchanged fields\n    to_remove = []\n    for field in new_book:\n        if old_book[field] == new_book[field] or new_book[field] is None:\n            to_remove.append(field)\n\n    for field in to_remove:\n        new_book.pop(field)\n\n    # If no fields to be changed remained, return a message\n    if len(new_book.keys()) == 0:\n        return {\"message\": \"Nothing new passed.\"}\n\n    # Update the book\n    if update_book_db(isbn, new_book):\n        return {\"message\": \"Book updated successfully\"}\n\n    return {\"message\": \"Something went wrong. Book not updated.\"}\n</code></pre>"},{"location":"db_schema/","title":"Database Schema","text":""},{"location":"db_schema/#overview","title":"Overview","text":"<p>Our system uses a PostgreSQL database with the <code>pgvector</code> extension to store the book data and the embeddings.</p>"},{"location":"db_schema/#tables","title":"Tables","text":"<p>Overall, we have the following tables in our database:</p> <ul> <li>Book - stores information about the books.</li> <li>Author - stores information about the authors.</li> <li>Genre - stores information about the genres.</li> <li>BookAuthor - stores the many-to-many relationship between books and authors.</li> <li>BookGenre - stores the many-to-many relationship between books and genres.</li> <li>History - stores the history of recommendations made to users.</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>To install the package, run the following command:</p> <pre><code>pip install kitab\n</code></pre> <p>To upgrade the package, run the following command:</p> <pre><code>pip install kitab --upgrade\n</code></pre>"},{"location":"getting_started/#requirements","title":"Requirements","text":"<p>Currently, the package only supports PostgreSQL databases. You need to have a PostgreSQL database installed on your machine to use the package.</p> <p>Additionally, since the package needs to store vectors, <code>pgvector</code> should be installed. To install it, follow the steps mentioned in the pgvector GitHub repo.</p> <p>All other requirements will be installed when the package is installed/updated using <code>pip</code>.</p>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>To start using the package functionalities, we need to load the data first. The data can be provided as a CSV file, which should include the following columns:</p> <p> Column Name Data Type Description isbn str the ISBN of the book title str the title of the book description str the description of the book author list[str] the author(s) of the book genre list[str] the genre(s) of the book available bool the availability of the book <p> </p> <p>Note: The table names might be different than the ones mentioned above. In that case, an additional parameter should be provided to specify the column names (<code>column_names</code> in <code>process_data()</code>).</p> <p>Before loading the data we need to process it. The <code>process_data()</code> function will process the data and generate the embeddings (this might take a while). It will split the data into parts, generate embeddings, store them in a specified folder. The folder will have numbered CSVs with the processed data and PKLs with the embeddings.</p> <pre><code>from kitab.utils import process_data\n\nfilepath = \"data.csv\"\ndestination_folder = \"data\"\n\nprocess_data(filepath, destination_folder)\n</code></pre> <p>Then we need to load the data into the database. For this, we need to provide the following database connection details in the <code>.env</code>:</p> <p> Parameter Description DB_USER str DB_PASSWORD str DB_HOST str DB_PORT str or int DB_NAME str <p> </p> <p>After that, we can load the data into the database using the <code>load_data()</code> function.</p> <pre><code>from dotenv import load_dotenv, find_dotenv\nload_dotenv(find_dotenv())\n\nfrom kitab.db.get_data import load_data\n\nload_data(destination_folder)\n</code></pre> <p>Now, we're ready to use the package functionalities. We can use the <code>recommend_books()</code> function to get recommendations for a book. The function takes the ISBN of the book and the number of recommendations you want to get.</p> <pre><code>from kitab.recommendation_model.models import recommend_books\n\ndescription = \"In this thrilling detective tale, a group of childhood friends accidentally stumble upon an ancient artifact hidden in their clubhouse. Little do they know, their discovery thrusts them into a dangerous conspiracy spanning centuries. As they uncover clues, they race against time to prevent a cataclysmic event that could reshape the world. Join them on a heart-pounding journey through shadows and secrets in this gripping mystery.\"\n\nrecommend_books(description, n=5)\n</code></pre> <p>We can get a recommendation for a book using its ISBN or title as well.</p> <pre><code>from kitab.recommendation_model.models import recommend_books_by_ISBN\n\nrecommend_books_by_ISBN(ISBN=\"1442942355\", n=5)\n</code></pre> <pre><code>from kitab.recommendation_model.models import recommend_books_by_title\n\nrecommend_books_by_title(title=\"The Ghostly Rental\", n=5)\n</code></pre>"},{"location":"getting_started/#api","title":"API","text":"<p>We have also implemented an API that can be used to interact with the model and the database. You can find information on API endpoints and how to use them in the documentation. To run the API, run the following:</p> <pre><code>from kitab.api.app import run_api\nrun_api(port=5552)\n</code></pre>"},{"location":"recommendation_model/","title":"Recommendation Model","text":""},{"location":"recommendation_model/#how-does-it-work","title":"How Does It Work?","text":"<p>Our recommendation model works by generating embeddings for the books and then calculating the cosine similarity between the embeddings of the input book and all other books. The books with the highest cosine similarity are recommended.</p>"},{"location":"recommendation_model/#additional-filtering","title":"Additional Filtering","text":"<p>Additional filters can be applied to ensure the model works faster. One such filter is the availability of the book. If the book is not available, it will not be recommended. This filter can be turned off if you want to recommend books irrespective of their availability.</p>"},{"location":"recommendation_model/#current-functionality","title":"Current Functionality","text":"<p>As of now, the package has the following functionality in terms of recommendations:</p>"},{"location":"recommendation_model/#kitab.recommendation_model.models","title":"<code>kitab.recommendation_model.models</code>","text":"<p>This module contains the functions for recommending books.</p>"},{"location":"recommendation_model/#kitab.recommendation_model.models.recommend_books","title":"<code>recommend_books(description, n, get_available=True, data=None)</code>","text":"<p>Recommends a list of books based on a given description.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.recommendation_model.models import recommend_books\n&gt;&gt;&gt; description = \"In this thrilling detective tale, a group of childhood friends accidentally stumble upon an ancient artifact hidden in their clubhouse. Little do they know, their discovery thrusts them into a dangerous conspiracy spanning centuries. As they uncover clues, they race against time to prevent a cataclysmic event that could reshape the world. Join them on a heart-pounding journey through shadows and secrets in this gripping mystery.\"\n&gt;&gt;&gt; recommend_books(description, n=5)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of the book.</p> required <code>n</code> <code>int</code> <p>The number of books to recommend.</p> required <code>get_available</code> <code>bool</code> <p>Whether to only recommend available books. Defaults to True.</p> <code>True</code> <code>data</code> <code>DataFrame</code> <p>The data containing book information. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of dictionaries representing the most similar books.</p> Source code in <code>kitab\\recommendation_model\\models.py</code> <pre><code>def recommend_books(description: str, n: int, get_available: bool = True, data : pd.DataFrame = None) -&gt; list[dict]:\n    \"\"\"\n    Recommends a list of books based on a given description.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.recommendation_model.models import recommend_books\n        &gt;&gt;&gt; description = \"In this thrilling detective tale, a group of childhood friends accidentally stumble upon an ancient artifact hidden in their clubhouse. Little do they know, their discovery thrusts them into a dangerous conspiracy spanning centuries. As they uncover clues, they race against time to prevent a cataclysmic event that could reshape the world. Join them on a heart-pounding journey through shadows and secrets in this gripping mystery.\"\n        &gt;&gt;&gt; recommend_books(description, n=5)\n\n    Parameters:\n        description (str): The description of the book.\n        n (int): The number of books to recommend.\n        get_available (bool, optional): Whether to only recommend available books. Defaults to True.\n        data (pd.DataFrame, optional): The data containing book information. Defaults to None.\n\n    Returns:\n        list[dict]: A list of dictionaries representing the most similar books.\n    \"\"\"\n    if data is None:\n        if get_available:\n            data = get_table_from_db(\"book\", conditions={\"available\": True})\n        else:\n            data = get_table_from_db(\"book\")\n    elif get_available:\n        data = data[data[\"available\"] == True]\n\n    # Check that description is not empty\n    if description == \"\": return []\n\n    # Get the embedding of the description\n    desc_embedding = get_embedding(description)\n\n    # Get all the embeddings for the existing book descriptions\n    embeddings = np.stack(data[\"embedding\"].values)\n\n    # Compute cosine similarities\n    cosine_similarities = cos_mat_vec(embeddings, desc_embedding)\n\n    # Find n most similar books\n    most_similar_indices = np.argsort(cosine_similarities)[-n:][::-1]\n\n    # Get the ISBNs of the books\n    most_similar_books = data.iloc[most_similar_indices]\n    most_similar_books.drop(columns=[\"embedding\"], inplace=True)\n    ISBNs = most_similar_books[\"isbn\"].tolist()\n\n    # Get a dict of authors and genres for the books\n    authors = get_authors(ISBNs)\n    genres = get_genres(ISBNs)\n\n    # Convert the most similar books to a list of dictionaries\n    books = most_similar_books.to_dict(orient=\"records\")\n\n    # Add the authors and genres to the books\n    for book in books:\n        book[\"authors\"] = authors[book[\"isbn\"]]\n        book[\"genres\"] = genres[book[\"isbn\"]]\n\n    # Return the most similar books\n    return books\n</code></pre>"},{"location":"recommendation_model/#kitab.recommendation_model.models.recommend_books_by_ISBN","title":"<code>recommend_books_by_ISBN(ISBN, n, get_available=True)</code>","text":"<p>Recommends a list of books based on the description of the book with the given ISBN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.recommendation_model.models import recommend_books_by_ISBN\n&gt;&gt;&gt; recommend_books_by_ISBN(ISBN=\"1442942355\", n=5)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ISBN</code> <code>str</code> <p>The ISBN of the book.</p> required <code>n</code> <code>int</code> <p>The number of books to recommend.</p> required <code>get_available</code> <code>bool</code> <p>Whether to only recommend available books. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of dictionaries representing the most similar books.</p> Source code in <code>kitab\\recommendation_model\\models.py</code> <pre><code>def recommend_books_by_ISBN(ISBN: str, n: int, get_available: bool = True) -&gt; list[dict]:\n    \"\"\"\n    Recommends a list of books based on the description of the book with the given ISBN.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.recommendation_model.models import recommend_books_by_ISBN\n        &gt;&gt;&gt; recommend_books_by_ISBN(ISBN=\"1442942355\", n=5)\n\n    Parameters:\n        ISBN (str): The ISBN of the book.\n        n (int): The number of books to recommend.\n        get_available (bool, optional): Whether to only recommend available books. Defaults to True.\n\n    Returns:\n        list[dict]: A list of dictionaries representing the most similar books.\n    \"\"\"\n    data = get_table_from_db(\"book\")\n\n    # Check that ISBN is not empty\n    if ISBN == \"\": return []\n\n    # Check that ISBN is in the data\n    if ISBN not in data[\"isbn\"].values: return []\n\n    # Get the book\n    book = data[data[\"isbn\"] == ISBN].iloc[0]\n\n    # Return the recommendations\n    return recommend_books(book[\"description\"], n, get_available, data)\n</code></pre>"},{"location":"recommendation_model/#kitab.recommendation_model.models.recommend_books_by_title","title":"<code>recommend_books_by_title(title, n, get_available=True)</code>","text":"<p>Recommends a list of books based on the description of the book with the given title.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.recommendation_model.models import recommend_books_by_title\n&gt;&gt;&gt; recommend_books_by_title(title=\"The Ghostly Rental\", n=5)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the book.</p> required <code>n</code> <code>int</code> <p>The number of books to recommend.</p> required <code>get_available</code> <code>bool</code> <p>Whether to only recommend available books. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of dictionaries representing the most similar books.</p> Source code in <code>kitab\\recommendation_model\\models.py</code> <pre><code>def recommend_books_by_title(title: str, n: int, get_available: bool = True) -&gt; list[dict]:\n    \"\"\"\n    Recommends a list of books based on the description of the book with the given title.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.recommendation_model.models import recommend_books_by_title\n        &gt;&gt;&gt; recommend_books_by_title(title=\"The Ghostly Rental\", n=5)\n\n    Parameters:\n        title (str): The title of the book.\n        n (int): The number of books to recommend.\n        get_available (bool, optional): Whether to only recommend available books. Defaults to True.\n\n    Returns:\n        list[dict]: A list of dictionaries representing the most similar books.\n    \"\"\"    \n    data = get_table_from_db(\"book\")\n\n    # Check that title is not empty\n    if title == \"\": return []\n\n    # Check that title is in the data\n    if title not in data[\"title\"].values: return []\n\n    # Get the book\n    book = data[data[\"title\"] == title].iloc[0]\n\n    # Return the recommendations\n    return recommend_books(book[\"description\"], n, get_available, data)\n</code></pre>"},{"location":"sql_interactions/","title":"SQL Interactions &amp; Functions","text":""},{"location":"sql_interactions/#database-interactions","title":"Database Interactions","text":"<p>We have implemented the following functionality to interact with the database:</p>"},{"location":"sql_interactions/#kitab.db.sql_interactions","title":"<code>kitab.db.sql_interactions</code>","text":"<p>This module contains the functions for interacting with the SQL database.</p>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler","title":"<code>SqlHandler</code>","text":"Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>class SqlHandler:\n\n    def __init__(self, dbname: str, user: str, password: str, host: str, port: str) -&gt; None:\n        # Check credentials\n        if any(not cred for cred in [dbname, user, password, host, port]):\n            raise Exception(\"Some database credentials were not passed. Please fill in the database credentials (DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME) in db_credentials.py.\")\n\n        self.connection = psycopg2.connect(dbname=dbname, user=user, password=password, host=host, port=port)\n        self.cursor = self.connection.cursor()\n        self.cursor.execute(\"CREATE EXTENSION IF NOT EXISTS vector;\")\n        register_vector(self.connection)\n\n    def close_cnxn(self, verbose: bool = False) -&gt; None:\n        \"\"\"\n        Close the connection to the database.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; db.close_cnxn()\n\n        Parameters:\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        if verbose:\n            logger.info('Committing the changes.')\n\n        self.connection.commit()\n        self.cursor.close()\n        self.connection.close()\n\n        if verbose:\n            logger.info('The connection has been closed.')\n\n\n    def get_table_columns(self, table_name: str, verbose: bool = False) -&gt; list:\n        \"\"\"\n        Retrieves the columns of a table in the database.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; db.get_table_columns(\"Book\")\n\n        Parameters:\n            table_name (str): The name of the table whose columns are to be retrieved.\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            list: A list of column names in the table.\n        \"\"\"\n        try:\n            self.cursor.execute(f\"SELECT column_name FROM information_schema.columns WHERE table_name = '{table_name}';\")\n            columns = self.cursor.fetchall()\n            column_names = [col[0] for col in columns]\n            if verbose:\n                logger.info(f'Retrieved columns for table {table_name}: {column_names}')\n            return column_names\n        except Exception as e:\n            if verbose:\n                logger.error(f'Error occurred while retrieving columns for table {table_name}: {e}')\n            return []\n\n\n    def execute_commands(self, commands: list, verbose: bool = False) -&gt; None:\n        \"\"\"\n        Executes a list of commands in the database.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; commands = [...]\n            &gt;&gt;&gt; db.execute_commands(commands)\n\n        Parameters:\n            commands (list): A list of SQL commands to be executed.\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        for command in commands:\n            self.cursor.execute(command)\n\n        self.connection.commit()\n\n        if verbose:\n            logger.info('Commands executed successfully.')\n\n\n    def insert_many(self, df: pd.DataFrame, table_name: str, verbose: bool = False) -&gt; None:\n        \"\"\"\n        Inserts data from a DataFrame into a table in the database.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; df = pd.DataFrame(...)\n            &gt;&gt;&gt; db.insert_many(df, \"Book\")\n\n        Parameters:\n            df (pd.DataFrame): The DataFrame containing the data to be inserted.\n            table_name (str): The name of the table to be dropped.\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        try:\n            df = df.replace(np.nan, None)  # for handling NULLS\n            df.rename(columns=lambda x: x.lower(), inplace=True)\n            columns = list(df.columns)\n\n            if verbose:\n                logger.info(f'Columns before intersection: {columns}')\n\n            sql_column_names = [i.lower() for i in self.get_table_columns(table_name)]\n            columns = list(set(columns) &amp; set(sql_column_names))\n\n            if verbose:\n                logger.info(f'Columns after intersection: {columns}')\n\n            data_to_insert = df.loc[:, columns]\n            values = []\n\n            for row in data_to_insert.itertuples(index=False):\n                values.append(tuple(row))\n\n            if verbose:\n                logger.info(f'Shape of the table to be imported: {data_to_insert.shape}')\n\n            ncolumns = len(columns)\n            params = ','.join(['%s'] * ncolumns)\n\n            if len(columns) &gt; 1:\n                cols = ', '.join(columns)\n            else:\n                cols = columns[0]\n\n            if verbose:\n                logger.info(f'Insert structure: Columns: {cols}, Parameters: {params}')\n\n            query = f\"INSERT INTO {table_name} ({cols}) VALUES ({params});\"\n\n            if verbose:\n                logger.info(f'Query: {query}')\n\n            self.cursor.executemany(query, values)\n            self.connection.commit()\n\n            if verbose:\n                logger.info('Data loaded successfully.')\n        except Exception as e:\n            logger.error(f'Error occurred while inserting data into {table_name}: {e}')\n\n\n    def truncate_table(self, table_name: str, verbose: bool = False) -&gt; None:\n        \"\"\"\n        Truncates a table from the database.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; db.truncate_table(\"Book\")\n\n        Parameters:\n            table_name (str): The name of the table to be truncated.\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        query = f\"\"\" TRUNCATE TABLE {table_name} CASCADE; \"\"\"   #if exists\n        self.cursor.execute(query)\n\n        if verbose:\n            logger.info(f'the {table_name} is truncated')\n\n        # self.cursor.close()\n\n\n    def drop_table(self, table_name: str, verbose: bool = False) -&gt; None:\n        \"\"\"\n        Drops a table from the database if it exists.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; db.drop_table(\"Book\")\n\n        Parameters:\n            table_name (str): The name of the table to be dropped.\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        query = f\"DROP TABLE IF EXISTS {table_name};\"\n        if verbose:\n                logger.info(query)\n\n        self.cursor.execute(query)\n\n        self.close_cnxn.commit()\n\n        if verbose:\n            logger.info(f\"Table '{table_name}' deleted.\")\n\n\n    def insert_records(self, table_name: str, values_list: list[dict], verbose: bool = False) -&gt; None:\n        \"\"\"\n        Insert one or more records into the database table.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; list_of_books = [...]\n            &gt;&gt;&gt; db.insert_records(\"Book\", list_of_books)\n\n        Parameters:\n            values_list (List[Dict]): A list of dictionaries containing column names as keys and their values as values.\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        if not values_list:\n            logger.warning(\"No records to insert.\")\n            return            \n\n        columns = ', '.join(values_list[0].keys())\n        placeholders = '(' + ', '.join(['%s'] * len(values_list[0])) + ')'\n        query = f\"INSERT INTO {table_name} ({columns}) VALUES {placeholders};\"        \n        values = [tuple(value.values()) for value in values_list]\n\n        self.cursor.executemany(query, values)\n        self.connection.commit()\n\n        if verbose:\n            logger.info(f\"{len(values_list)} records inserted successfully.\")\n\n\n    def update_records(self, table_name: str, updated_values: dict, condition: dict, verbose: bool = False) -&gt; None:\n        \"\"\"\n        Update records in the database table based on a given condition.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; updated_values = {...}\n            &gt;&gt;&gt; conditions = {...}\n            &gt;&gt;&gt; db.update_records(\"Book\", updated_values, conditions)        \n\n        Parameters:\n            table_name (str): The name of the table to update records in.\n            condition (dict): A dictionary representing the condition for selecting records to update.\n            updated_values (dict): A dictionary containing column names as keys and their updated values as values.\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        if not condition:\n            logger.warning(\"No condition provided for updating records.\")\n            return\n\n        if not updated_values:\n            logger.warning(\"No values provided for update.\")\n            return\n\n        set_clause = ', '.join([f\"{column} = %s\" for column in updated_values.keys()])\n        condition_clause = ' AND '.join([f\"{column} = %s\" for column in condition.keys()])\n\n        query = f\"UPDATE {table_name} SET {set_clause} WHERE {condition_clause};\"\n        values = list(updated_values.values()) + list(condition.values())\n\n        self.cursor.execute(query, tuple(values))\n        self.connection.commit()\n\n        if verbose:\n            logger.info(\"Records updated successfully.\")\n\n    def remove_records(self, table_name: str, conditions_list: list[dict], verbose: bool = False) -&gt; None:\n        \"\"\"\n        Remove records from the database table based on multiple conditions.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; list_of_conditions = [...]\n            &gt;&gt;&gt; db.remove_records(\"Book\", list_of_conditions)          \n\n        Parameters:\n            table_name (str): The name of the table to remove records from.\n            conditions_list (list[dict]): A list of dictionaries representing conditions for selecting records to remove.\n                The conditions inside each dictionary are concatenated using AND, and the dictionaries inside the list are concatenated using OR.\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            None\n        \"\"\"\n        if not conditions_list:\n            logger.warning(\"No conditions provided for removing records.\")\n            return\n\n        condition_clauses = []\n        values = []\n\n        for condition in conditions_list:\n            condition_clause = ' AND '.join([f\"{column} = %s\" for column in condition.keys()])\n            condition_clauses.append(f\"({condition_clause})\")\n            values.extend(list(condition.values()))\n\n        where_clause = ' OR '.join(condition_clauses)\n        query = f\"DELETE FROM {table_name} WHERE {where_clause};\"\n\n        self.cursor.execute(query, tuple(values))\n        self.connection.commit()\n\n        if verbose:\n            logger.info(\"Records removed successfully.\")\n\n    def get_table(self, table_name: str, conditions: dict = None, verbose: bool = False) -&gt; pd.DataFrame:\n        \"\"\"\n        Retrieve data from the database table.\n\n        Examples:\n            &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n            &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n            &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n            &gt;&gt;&gt; list_of_conditions = [...]\n            &gt;&gt;&gt; db.get_table(\"Book\", list_of_conditions)          \n\n        Parameters:\n            table_name (str): The name of the table to retrieve data from.\n            conditions (dict, optional): A dictionary representing the conditions to filter records. Defaults to None.\n            verbose (bool): Whether to print verbose output. Defaults to False.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing the retrieved data.\n        \"\"\"\n        if conditions:\n            condition_clauses = []\n            values = []\n            for column, value in conditions.items():\n                if isinstance(value, list):\n                    placeholders = ', '.join(['%s'] * len(value))\n                    condition_clauses.append(f\"{column} IN ({placeholders})\")\n                    values.extend(value)\n                else:\n                    condition_clauses.append(f\"{column} = %s\")\n                    values.append(value)\n\n            condition_clause = ' AND '.join(condition_clauses)\n            query = f\"SELECT * FROM {table_name} WHERE {condition_clause};\"\n            data = pd.read_sql(query, self.connection, params=values)\n        else:\n            query = f\"SELECT * FROM {table_name};\"\n            data = pd.read_sql(query, self.connection)\n\n        if verbose:\n            logger.info(\"Table retrieved successfully.\")\n\n        return data\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.close_cnxn","title":"<code>close_cnxn(verbose=False)</code>","text":"<p>Close the connection to the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; db.close_cnxn()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def close_cnxn(self, verbose: bool = False) -&gt; None:\n    \"\"\"\n    Close the connection to the database.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; db.close_cnxn()\n\n    Parameters:\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    if verbose:\n        logger.info('Committing the changes.')\n\n    self.connection.commit()\n    self.cursor.close()\n    self.connection.close()\n\n    if verbose:\n        logger.info('The connection has been closed.')\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.drop_table","title":"<code>drop_table(table_name, verbose=False)</code>","text":"<p>Drops a table from the database if it exists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; db.drop_table(\"Book\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to be dropped.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def drop_table(self, table_name: str, verbose: bool = False) -&gt; None:\n    \"\"\"\n    Drops a table from the database if it exists.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; db.drop_table(\"Book\")\n\n    Parameters:\n        table_name (str): The name of the table to be dropped.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    query = f\"DROP TABLE IF EXISTS {table_name};\"\n    if verbose:\n            logger.info(query)\n\n    self.cursor.execute(query)\n\n    self.close_cnxn.commit()\n\n    if verbose:\n        logger.info(f\"Table '{table_name}' deleted.\")\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.execute_commands","title":"<code>execute_commands(commands, verbose=False)</code>","text":"<p>Executes a list of commands in the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; commands = [...]\n&gt;&gt;&gt; db.execute_commands(commands)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>list</code> <p>A list of SQL commands to be executed.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def execute_commands(self, commands: list, verbose: bool = False) -&gt; None:\n    \"\"\"\n    Executes a list of commands in the database.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; commands = [...]\n        &gt;&gt;&gt; db.execute_commands(commands)\n\n    Parameters:\n        commands (list): A list of SQL commands to be executed.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    for command in commands:\n        self.cursor.execute(command)\n\n    self.connection.commit()\n\n    if verbose:\n        logger.info('Commands executed successfully.')\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.get_table","title":"<code>get_table(table_name, conditions=None, verbose=False)</code>","text":"<p>Retrieve data from the database table.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; list_of_conditions = [...]\n&gt;&gt;&gt; db.get_table(\"Book\", list_of_conditions)          \n</code></pre> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to retrieve data from.</p> required <code>conditions</code> <code>dict</code> <p>A dictionary representing the conditions to filter records. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the retrieved data.</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def get_table(self, table_name: str, conditions: dict = None, verbose: bool = False) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieve data from the database table.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; list_of_conditions = [...]\n        &gt;&gt;&gt; db.get_table(\"Book\", list_of_conditions)          \n\n    Parameters:\n        table_name (str): The name of the table to retrieve data from.\n        conditions (dict, optional): A dictionary representing the conditions to filter records. Defaults to None.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the retrieved data.\n    \"\"\"\n    if conditions:\n        condition_clauses = []\n        values = []\n        for column, value in conditions.items():\n            if isinstance(value, list):\n                placeholders = ', '.join(['%s'] * len(value))\n                condition_clauses.append(f\"{column} IN ({placeholders})\")\n                values.extend(value)\n            else:\n                condition_clauses.append(f\"{column} = %s\")\n                values.append(value)\n\n        condition_clause = ' AND '.join(condition_clauses)\n        query = f\"SELECT * FROM {table_name} WHERE {condition_clause};\"\n        data = pd.read_sql(query, self.connection, params=values)\n    else:\n        query = f\"SELECT * FROM {table_name};\"\n        data = pd.read_sql(query, self.connection)\n\n    if verbose:\n        logger.info(\"Table retrieved successfully.\")\n\n    return data\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.get_table_columns","title":"<code>get_table_columns(table_name, verbose=False)</code>","text":"<p>Retrieves the columns of a table in the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; db.get_table_columns(\"Book\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table whose columns are to be retrieved.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of column names in the table.</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def get_table_columns(self, table_name: str, verbose: bool = False) -&gt; list:\n    \"\"\"\n    Retrieves the columns of a table in the database.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; db.get_table_columns(\"Book\")\n\n    Parameters:\n        table_name (str): The name of the table whose columns are to be retrieved.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        list: A list of column names in the table.\n    \"\"\"\n    try:\n        self.cursor.execute(f\"SELECT column_name FROM information_schema.columns WHERE table_name = '{table_name}';\")\n        columns = self.cursor.fetchall()\n        column_names = [col[0] for col in columns]\n        if verbose:\n            logger.info(f'Retrieved columns for table {table_name}: {column_names}')\n        return column_names\n    except Exception as e:\n        if verbose:\n            logger.error(f'Error occurred while retrieving columns for table {table_name}: {e}')\n        return []\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.insert_many","title":"<code>insert_many(df, table_name, verbose=False)</code>","text":"<p>Inserts data from a DataFrame into a table in the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; df = pd.DataFrame(...)\n&gt;&gt;&gt; db.insert_many(df, \"Book\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame containing the data to be inserted.</p> required <code>table_name</code> <code>str</code> <p>The name of the table to be dropped.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def insert_many(self, df: pd.DataFrame, table_name: str, verbose: bool = False) -&gt; None:\n    \"\"\"\n    Inserts data from a DataFrame into a table in the database.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; df = pd.DataFrame(...)\n        &gt;&gt;&gt; db.insert_many(df, \"Book\")\n\n    Parameters:\n        df (pd.DataFrame): The DataFrame containing the data to be inserted.\n        table_name (str): The name of the table to be dropped.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        df = df.replace(np.nan, None)  # for handling NULLS\n        df.rename(columns=lambda x: x.lower(), inplace=True)\n        columns = list(df.columns)\n\n        if verbose:\n            logger.info(f'Columns before intersection: {columns}')\n\n        sql_column_names = [i.lower() for i in self.get_table_columns(table_name)]\n        columns = list(set(columns) &amp; set(sql_column_names))\n\n        if verbose:\n            logger.info(f'Columns after intersection: {columns}')\n\n        data_to_insert = df.loc[:, columns]\n        values = []\n\n        for row in data_to_insert.itertuples(index=False):\n            values.append(tuple(row))\n\n        if verbose:\n            logger.info(f'Shape of the table to be imported: {data_to_insert.shape}')\n\n        ncolumns = len(columns)\n        params = ','.join(['%s'] * ncolumns)\n\n        if len(columns) &gt; 1:\n            cols = ', '.join(columns)\n        else:\n            cols = columns[0]\n\n        if verbose:\n            logger.info(f'Insert structure: Columns: {cols}, Parameters: {params}')\n\n        query = f\"INSERT INTO {table_name} ({cols}) VALUES ({params});\"\n\n        if verbose:\n            logger.info(f'Query: {query}')\n\n        self.cursor.executemany(query, values)\n        self.connection.commit()\n\n        if verbose:\n            logger.info('Data loaded successfully.')\n    except Exception as e:\n        logger.error(f'Error occurred while inserting data into {table_name}: {e}')\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.insert_records","title":"<code>insert_records(table_name, values_list, verbose=False)</code>","text":"<p>Insert one or more records into the database table.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; list_of_books = [...]\n&gt;&gt;&gt; db.insert_records(\"Book\", list_of_books)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>values_list</code> <code>List[Dict]</code> <p>A list of dictionaries containing column names as keys and their values as values.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def insert_records(self, table_name: str, values_list: list[dict], verbose: bool = False) -&gt; None:\n    \"\"\"\n    Insert one or more records into the database table.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; list_of_books = [...]\n        &gt;&gt;&gt; db.insert_records(\"Book\", list_of_books)\n\n    Parameters:\n        values_list (List[Dict]): A list of dictionaries containing column names as keys and their values as values.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    if not values_list:\n        logger.warning(\"No records to insert.\")\n        return            \n\n    columns = ', '.join(values_list[0].keys())\n    placeholders = '(' + ', '.join(['%s'] * len(values_list[0])) + ')'\n    query = f\"INSERT INTO {table_name} ({columns}) VALUES {placeholders};\"        \n    values = [tuple(value.values()) for value in values_list]\n\n    self.cursor.executemany(query, values)\n    self.connection.commit()\n\n    if verbose:\n        logger.info(f\"{len(values_list)} records inserted successfully.\")\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.remove_records","title":"<code>remove_records(table_name, conditions_list, verbose=False)</code>","text":"<p>Remove records from the database table based on multiple conditions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; list_of_conditions = [...]\n&gt;&gt;&gt; db.remove_records(\"Book\", list_of_conditions)          \n</code></pre> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to remove records from.</p> required <code>conditions_list</code> <code>list[dict]</code> <p>A list of dictionaries representing conditions for selecting records to remove. The conditions inside each dictionary are concatenated using AND, and the dictionaries inside the list are concatenated using OR.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def remove_records(self, table_name: str, conditions_list: list[dict], verbose: bool = False) -&gt; None:\n    \"\"\"\n    Remove records from the database table based on multiple conditions.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; list_of_conditions = [...]\n        &gt;&gt;&gt; db.remove_records(\"Book\", list_of_conditions)          \n\n    Parameters:\n        table_name (str): The name of the table to remove records from.\n        conditions_list (list[dict]): A list of dictionaries representing conditions for selecting records to remove.\n            The conditions inside each dictionary are concatenated using AND, and the dictionaries inside the list are concatenated using OR.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    if not conditions_list:\n        logger.warning(\"No conditions provided for removing records.\")\n        return\n\n    condition_clauses = []\n    values = []\n\n    for condition in conditions_list:\n        condition_clause = ' AND '.join([f\"{column} = %s\" for column in condition.keys()])\n        condition_clauses.append(f\"({condition_clause})\")\n        values.extend(list(condition.values()))\n\n    where_clause = ' OR '.join(condition_clauses)\n    query = f\"DELETE FROM {table_name} WHERE {where_clause};\"\n\n    self.cursor.execute(query, tuple(values))\n    self.connection.commit()\n\n    if verbose:\n        logger.info(\"Records removed successfully.\")\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.truncate_table","title":"<code>truncate_table(table_name, verbose=False)</code>","text":"<p>Truncates a table from the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; db.truncate_table(\"Book\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to be truncated.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def truncate_table(self, table_name: str, verbose: bool = False) -&gt; None:\n    \"\"\"\n    Truncates a table from the database.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; db.truncate_table(\"Book\")\n\n    Parameters:\n        table_name (str): The name of the table to be truncated.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    query = f\"\"\" TRUNCATE TABLE {table_name} CASCADE; \"\"\"   #if exists\n    self.cursor.execute(query)\n\n    if verbose:\n        logger.info(f'the {table_name} is truncated')\n</code></pre>"},{"location":"sql_interactions/#kitab.db.sql_interactions.SqlHandler.update_records","title":"<code>update_records(table_name, updated_values, condition, verbose=False)</code>","text":"<p>Update records in the database table based on a given condition.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n&gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n&gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n&gt;&gt;&gt; updated_values = {...}\n&gt;&gt;&gt; conditions = {...}\n&gt;&gt;&gt; db.update_records(\"Book\", updated_values, conditions)        \n</code></pre> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to update records in.</p> required <code>condition</code> <code>dict</code> <p>A dictionary representing the condition for selecting records to update.</p> required <code>updated_values</code> <code>dict</code> <p>A dictionary containing column names as keys and their updated values as values.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\db\\sql_interactions.py</code> <pre><code>def update_records(self, table_name: str, updated_values: dict, condition: dict, verbose: bool = False) -&gt; None:\n    \"\"\"\n    Update records in the database table based on a given condition.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.sql_interactions import SqlHandler\n        &gt;&gt;&gt; from kitab.db.db_credentials import DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, DB_NAME\n        &gt;&gt;&gt; db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        &gt;&gt;&gt; updated_values = {...}\n        &gt;&gt;&gt; conditions = {...}\n        &gt;&gt;&gt; db.update_records(\"Book\", updated_values, conditions)        \n\n    Parameters:\n        table_name (str): The name of the table to update records in.\n        condition (dict): A dictionary representing the condition for selecting records to update.\n        updated_values (dict): A dictionary containing column names as keys and their updated values as values.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    if not condition:\n        logger.warning(\"No condition provided for updating records.\")\n        return\n\n    if not updated_values:\n        logger.warning(\"No values provided for update.\")\n        return\n\n    set_clause = ', '.join([f\"{column} = %s\" for column in updated_values.keys()])\n    condition_clause = ' AND '.join([f\"{column} = %s\" for column in condition.keys()])\n\n    query = f\"UPDATE {table_name} SET {set_clause} WHERE {condition_clause};\"\n    values = list(updated_values.values()) + list(condition.values())\n\n    self.cursor.execute(query, tuple(values))\n    self.connection.commit()\n\n    if verbose:\n        logger.info(\"Records updated successfully.\")\n</code></pre>"},{"location":"sql_interactions/#functions","title":"Functions","text":""},{"location":"sql_interactions/#kitab.db.functions","title":"<code>kitab.db.functions</code>","text":"<p>This module contains tailored functions for interacting with the database. These are used by the API and the recommendation model.</p>"},{"location":"sql_interactions/#kitab.db.functions.add_book_db","title":"<code>add_book_db(book, verbose=False)</code>","text":"<p>Adds a book to the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.functions import add_book_db\n&gt;&gt;&gt; add_book_db({\n        \"isbn\": \"1442942355\",\n        \"title\": \"The Ghostly Rental\",\n        \"description\": \"Employing the subtle methods of presenting mysterious ghost stories in the backdrop of psychological troubles, the novel presents the life of James. The troubles that he faces, combined with the baffling events around him give an aura to the novel that is almost unsurpassable\",\n        \"available\": False,\n        \"authors\": [\n            \"Henry James\"\n        ],\n        \"genres\": [\n            \"Horror\",\n            \"Short Stories\",\n            \"The United States Of America\"\n        ]\n    })\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>book</code> <code>dict</code> <p>A dictionary containing the book information.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the book was successfully added, False otherwise.</p> Source code in <code>kitab\\db\\functions.py</code> <pre><code>def add_book_db(book: dict, verbose: bool = False) -&gt; bool:\n    \"\"\"\n    Adds a book to the database.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.functions import add_book_db\n        &gt;&gt;&gt; add_book_db({\n                \"isbn\": \"1442942355\",\n                \"title\": \"The Ghostly Rental\",\n                \"description\": \"Employing the subtle methods of presenting mysterious ghost stories in the backdrop of psychological troubles, the novel presents the life of James. The troubles that he faces, combined with the baffling events around him give an aura to the novel that is almost unsurpassable\",\n                \"available\": False,\n                \"authors\": [\n                    \"Henry James\"\n                ],\n                \"genres\": [\n                    \"Horror\",\n                    \"Short Stories\",\n                    \"The United States Of America\"\n                ]\n            })\n\n    Parameters:\n        book (dict): A dictionary containing the book information.\n\n    Returns:\n        bool: True if the book was successfully added, False otherwise.\n    \"\"\"\n    try:\n        # Open connection to the database\n        db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        if verbose:\n            logger.info(\"Database connection opened.\")\n\n        # Extract information from the book dictionary\n        ISBN = book[\"isbn\"]\n        title = book[\"title\"]\n        description = book[\"description\"]\n        available = book[\"available\"]\n        embedding = get_embedding(book[\"description\"]).tolist()\n\n        db.insert_records(\"book\", [{\"isbn\": ISBN, \"title\": title, \"description\": description, \"embedding\": embedding, \"available\": available}])\n        if verbose:\n            logger.info(\"Book table populated.\")\n\n        # Add author(s) to the author table if doesn't exist\n        authors = book[\"authors\"]\n        if len(authors) &gt; 0:\n            if verbose:\n                logger.info(\"Authors to be added.\")\n            author_ids = _get_or_add_authors(db, authors, verbose=verbose)\n\n            db.insert_records(\"bookauthor\", [{\"isbn\": ISBN, \"author_id\": int(author_id)} for author_id in author_ids], verbose=verbose)\n            if verbose:\n                logger.info(\"Author table populated.\")\n        else:\n            if verbose:\n                logger.info(\"No authors to be added.\")\n\n        # Add genres to the genres table if doesn't exist\n        genres = book[\"genres\"]    \n        if len(genres) &gt; 0:\n            if verbose:\n                logger.info(\"Genres to be added.\")\n            genre_ids = _get_or_add_genres(db, genres, verbose=verbose)\n\n            db.insert_records(\"bookgenre\", [{\"isbn\": ISBN, \"genre_id\": int(genre_id)} for genre_id in genre_ids], verbose=verbose)\n            if verbose:\n                logger.info(\"Genre table populated.\")\n        else:\n            if verbose:\n                logger.info(\"No genres to be added.\")\n\n        return True\n    except:\n        return False    \n</code></pre>"},{"location":"sql_interactions/#kitab.db.functions.add_recommendation_log","title":"<code>add_recommendation_log(description, recommendation_isbn, successful, verbose=False)</code>","text":"<p>Adds a recommendation log to the history table.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.functions import add_recommendation_log\n&gt;&gt;&gt; add_recommendation_log(description=\"In a masterful blend of psychological intrigue and spectral disturbances, this novel unfurls the complex life of Clara. Her internal struggles are mirrored by eerie, inexplicable occurrences, weaving a tale that is both deeply personal and chillingly atmospheric, offering an unparalleled exploration of the human psyche shadowed by the paranormal.\", recommendation_isbn=\"1442942355\", successful=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>The description of the recommendation.</p> required <code>recommendation_isbn</code> <code>str</code> <p>The ISBN of the recommended book.</p> required <code>successful</code> <code>bool</code> <p>Whether the recommendation was successful or not.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the recommendation log was successfully added, False otherwise.</p> Source code in <code>kitab\\db\\functions.py</code> <pre><code>def add_recommendation_log(description: str, recommendation_isbn: str, successful: bool, verbose: bool = False) -&gt; bool:\n    \"\"\"\n    Adds a recommendation log to the history table.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.functions import add_recommendation_log\n        &gt;&gt;&gt; add_recommendation_log(description=\"In a masterful blend of psychological intrigue and spectral disturbances, this novel unfurls the complex life of Clara. Her internal struggles are mirrored by eerie, inexplicable occurrences, weaving a tale that is both deeply personal and chillingly atmospheric, offering an unparalleled exploration of the human psyche shadowed by the paranormal.\", recommendation_isbn=\"1442942355\", successful=True)\n\n    Parameters:\n        description (str): The description of the recommendation.\n        recommendation_isbn (str): The ISBN of the recommended book.\n        successful (bool): Whether the recommendation was successful or not.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        bool: True if the recommendation log was successfully added, False otherwise.\n    \"\"\"\n    try:\n        # Open connection to the database\n        db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        if verbose:\n            logger.info(\"Database connection opened.\")\n\n        # Insert the recommendation log into the history table\n        db.insert_records(\"history\", [{\"description\": description, \"recommendation_isbn\": recommendation_isbn, \"successful\": successful}], verbose=verbose)\n\n        return True\n    except Exception as e:\n        logger.error(\"Error adding recommendation log.\")\n        return False\n</code></pre>"},{"location":"sql_interactions/#kitab.db.functions.get_authors","title":"<code>get_authors(ISBNs, verbose=False)</code>","text":"<p>Get the authors for the given list of ISBNs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.functions import get_authors\n&gt;&gt;&gt; get_authors(ISBNs=[\"1442942355\", \"1613720211\"])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ISBNs</code> <code>list[str]</code> <p>A list of ISBNs.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str:list]</code> <p>dict[str:list]: A dictionary containing the authors for each ISBN.</p> Source code in <code>kitab\\db\\functions.py</code> <pre><code>def get_authors(ISBNs: list[str], verbose: bool = False) -&gt; dict[str:list]:\n    \"\"\"\n    Get the authors for the given list of ISBNs.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.functions import get_authors\n        &gt;&gt;&gt; get_authors(ISBNs=[\"1442942355\", \"1613720211\"])\n\n    Parameters:\n        ISBNs (list[str]): A list of ISBNs.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        dict[str:list]: A dictionary containing the authors for each ISBN.\n    \"\"\"\n    # Open connection to the database\n    db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n    if verbose:\n        logger.info(\"Database connection opened.\")\n\n    # Retrieve the authors of the books with the given ISBNs\n    authors = db.get_table(\"bookauthor\", conditions={\"isbn\": ISBNs}, verbose=verbose)\n    author_ids = authors[\"author_id\"].tolist()\n\n    author_table = db.get_table(\"author\", conditions={\"author_id\": author_ids}, verbose=verbose)\n\n    # Initialize dictionary to store authors for each ISBN\n    isbn_authors = {isbn: [] for isbn in ISBNs}\n\n    # Populate dictionary with authors\n    for _, row in authors.iterrows():\n        isbn = row[\"isbn\"]\n        author_id = row[\"author_id\"]\n        author_name = author_table.loc[author_table['author_id'] == author_id, 'full_name'].iloc[0]\n        isbn_authors[isbn].append(author_name)\n\n    # Return the dictionary of lists\n    return isbn_authors\n</code></pre>"},{"location":"sql_interactions/#kitab.db.functions.get_book_by_ISBN","title":"<code>get_book_by_ISBN(ISBN, verbose=False)</code>","text":"<p>Retrieves a book from the database based on its ISBN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.functions import get_book_by_ISBN\n&gt;&gt;&gt; get_book_by_ISBN(\"1442942355\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ISBN</code> <code>str</code> <p>The ISBN of the book to retrieve.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[dict]</code> <p>tuple[dict]: A tuple containing the book information, authors, and genres if found, or None if no book is found.</p> Source code in <code>kitab\\db\\functions.py</code> <pre><code>def get_book_by_ISBN(ISBN: str, verbose: bool = False) -&gt; tuple[dict]:\n    \"\"\"\n    Retrieves a book from the database based on its ISBN.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.functions import get_book_by_ISBN\n        &gt;&gt;&gt; get_book_by_ISBN(\"1442942355\")\n\n    Parameters:\n        ISBN (str): The ISBN of the book to retrieve.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        tuple[dict]: A tuple containing the book information, authors, and genres if found, or None if no book is found.\n    \"\"\"\n\n    # Open connection to the database\n    db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n    if verbose:\n        logger.info(\"Database connection opened.\")\n\n    # Retrieve the book with the given ISBN\n    book = db.get_table(\"book\", conditions={\"isbn\": ISBN})\n\n    if len(book) == 0:\n        logger.info(\"Book not found.\")\n        return None\n\n    if verbose:\n        logger.info(\"Book retrieved.\")\n\n    book_author = db.get_table(\"bookauthor\", conditions={\"isbn\": ISBN})\n    book_genre = db.get_table(\"bookgenre\", conditions={\"isbn\": ISBN})\n\n    # If no book found, return None\n    if len(book) == 0:\n        return None, None, None\n\n    book.drop(columns=[\"embedding\"], inplace=True)\n    book = book.to_dict(orient='records')[0]\n\n    author_ids = book_author[\"author_id\"].tolist()\n    authors = []\n    if len(author_ids) &gt; 0:\n        author = db.get_table(\"author\", conditions={\"author_id\": author_ids})\n        authors = author[\"full_name\"].tolist()\n        if verbose:\n            logger.info(f\"Authors retrieved.\")\n    else:\n        if verbose:\n            logger.info(\"No authors found.\")\n\n    genre_ids = book_genre[\"genre_id\"].tolist()\n    genres = []\n    if len(genre_ids) &gt; 0:\n        genre = db.get_table(\"genre\", conditions={\"genre_id\": genre_ids})\n        genres = genre[\"genre\"].tolist()\n        if verbose:\n            logger.info(f\"Genres retrieved.\")\n    else:\n        if verbose:\n            logger.info(\"No genres found.\")\n\n    book[\"authors\"] = authors\n    book[\"genres\"] = genres\n\n    # Return the book\n    return book\n</code></pre>"},{"location":"sql_interactions/#kitab.db.functions.get_book_by_title","title":"<code>get_book_by_title(title, verbose=False)</code>","text":"<p>Retrieves a book from the database based on its title.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.functions import get_book_by_title\n&gt;&gt;&gt; get_book_by_title(\"The Ghostly Rental\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the book to retrieve.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[dict]</code> <p>tuple[dict]: A tuple containing the book information, authors, and genres if found, or None if no book is found.</p> Source code in <code>kitab\\db\\functions.py</code> <pre><code>def get_book_by_title(title: str, verbose: bool = False) -&gt; tuple[dict]:\n    \"\"\"\n    Retrieves a book from the database based on its title.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.functions import get_book_by_title\n        &gt;&gt;&gt; get_book_by_title(\"The Ghostly Rental\")\n\n    Parameters:\n        title (str): The title of the book to retrieve.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        tuple[dict]: A tuple containing the book information, authors, and genres if found, or None if no book is found.\n    \"\"\"\n    # Open connection to the database\n    db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n    if verbose:\n        logger.info(\"Database connection opened.\")\n\n    # Retrieve the book with the given title\n    books = db.get_table(\"book\", conditions={\"title\": title}, verbose=verbose)\n\n    if len(books) == 0:\n        if verbose:\n            logger.info(\"Book not found.\")\n        return None\n    else:\n        if verbose:\n            logger.info(\"Book ISBN retrieved.\")\n        ISBN = books[\"isbn\"].values[0]\n\n    # Return the book\n    return get_book_by_ISBN(ISBN)\n</code></pre>"},{"location":"sql_interactions/#kitab.db.functions.get_genres","title":"<code>get_genres(ISBNs, verbose=False)</code>","text":"<p>Get the genres for the given list of ISBNs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.functions import get_genres\n&gt;&gt;&gt; get_genres(ISBNs=[\"1442942355\", \"1613720211\"])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ISBNs</code> <code>list[str]</code> <p>A list of ISBNs.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str:list]</code> <p>dict[str:list]: A dictionary containing the genres for each ISBN.</p> Source code in <code>kitab\\db\\functions.py</code> <pre><code>def get_genres(ISBNs: list[str], verbose: bool = False) -&gt; dict[str:list]:\n    \"\"\"\n    Get the genres for the given list of ISBNs.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.functions import get_genres\n        &gt;&gt;&gt; get_genres(ISBNs=[\"1442942355\", \"1613720211\"])\n\n    Parameters:\n        ISBNs (list[str]): A list of ISBNs.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        dict[str:list]: A dictionary containing the genres for each ISBN.\n    \"\"\"\n    # Open connection to the database\n    db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n    if verbose:\n        logger.info(\"Database connection opened.\")\n\n    # Retrieve the genres of the books with the given ISBNs\n    genres = db.get_table(\"bookgenre\", conditions={\"isbn\": ISBNs}, verbose=verbose)\n    genre_ids = genres[\"genre_id\"].tolist()\n\n    genre_table = db.get_table(\"genre\", conditions={\"genre_id\": genre_ids}, verbose=verbose)\n\n    # Initialize dictionary to store genres for each ISBN\n    isbn_genres = {isbn: [] for isbn in ISBNs}\n\n    # Populate dictionary with genres\n    for _, row in genres.iterrows():\n        isbn = row[\"isbn\"]\n        genre_id = row[\"genre_id\"]\n        genre_name = genre_table.loc[genre_table['genre_id'] == genre_id, 'genre'].iloc[0]\n        isbn_genres[isbn].append(genre_name)\n\n    # Return the dictionary of lists\n    return isbn_genres\n</code></pre>"},{"location":"sql_interactions/#kitab.db.functions.get_history_by_recommendation_isbn","title":"<code>get_history_by_recommendation_isbn(recommendation_isbn, verbose=False)</code>","text":"<p>Get the history of recommendations for a book with the given ISBN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.functions import get_history_by_recommendation_isbn\n&gt;&gt;&gt; get_history_by_recommendation_isbn(recommendation_isbn=\"1442942355\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>recommendation_isbn</code> <code>str</code> <p>The ISBN of the recommended book.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the history of recommendations for the book.</p> Source code in <code>kitab\\db\\functions.py</code> <pre><code>def get_history_by_recommendation_isbn(recommendation_isbn: str, verbose: bool = False) -&gt; dict:\n    \"\"\"\n    Get the history of recommendations for a book with the given ISBN.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.functions import get_history_by_recommendation_isbn\n        &gt;&gt;&gt; get_history_by_recommendation_isbn(recommendation_isbn=\"1442942355\")\n\n    Parameters:\n        recommendation_isbn (str): The ISBN of the recommended book.\n\n    Returns:\n        dict: A dictionary containing the history of recommendations for the book.\n    \"\"\"\n    # Open connection to the database\n    db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n    if verbose:\n        logger.info(\"Database connection opened.\")\n\n    # Retrieve the history of books that have been recommended\n    history = db.get_table(\"history\", conditions={\"recommendation_ISBN\": recommendation_isbn}, verbose=verbose)\n\n    # Return the history\n    return history.drop(columns=\"log_id\").to_dict(orient='records')\n</code></pre>"},{"location":"sql_interactions/#kitab.db.functions.get_table_from_db","title":"<code>get_table_from_db(table_name, conditions=None, verbose=False)</code>","text":"<p>Retrieves a table from the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.functions import get_table_from_db\n&gt;&gt;&gt; get_table_from_db(\"book\", conditions={\"available\": True})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to retrieve.</p> required <code>conditions</code> <code>dict</code> <p>A dictionary of conditions to filter the table.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the table information.</p> Source code in <code>kitab\\db\\functions.py</code> <pre><code>def get_table_from_db(table_name: str, conditions: dict = None, verbose: bool = False) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves a table from the database.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.functions import get_table_from_db\n        &gt;&gt;&gt; get_table_from_db(\"book\", conditions={\"available\": True})\n\n    Parameters:\n        table_name (str): The name of the table to retrieve.\n        conditions (dict): A dictionary of conditions to filter the table.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the table information.\n    \"\"\"\n    # Open connection to the database\n    db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n    if verbose:\n        logger.info(\"Database connection opened.\")\n\n    # Retrieve the table from the database\n    if conditions:\n        table = db.get_table(table_name, conditions=conditions, verbose=verbose)\n    else:\n        table = db.get_table(table_name, verbose=verbose)\n\n    if verbose:\n        logger.info(f\"Table {table_name} retrieved.\")\n\n    # Return the table\n    return table\n</code></pre>"},{"location":"sql_interactions/#kitab.db.functions.update_book_db","title":"<code>update_book_db(ISBN, new_book, verbose=False)</code>","text":"<p>Updates a book in the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.functions import update_book_db\n&gt;&gt;&gt; update_book_db(\"1442942355\", {\n        \"available\": True,\n        \"genres\": [\n            \"Horror\",\n            \"Short Stories\",\n            \"Mystery\"\n        ]\n    })\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ISBN</code> <code>str</code> <p>The ISBN of the book to update.</p> required <code>new_book</code> <code>dict</code> <p>A dictionary containing the updated book information.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print verbose output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the book was successfully updated, False otherwise.</p> Source code in <code>kitab\\db\\functions.py</code> <pre><code>def update_book_db(ISBN: str, new_book: dict, verbose: bool = False) -&gt; bool:\n    \"\"\"\n    Updates a book in the database.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.functions import update_book_db\n        &gt;&gt;&gt; update_book_db(\"1442942355\", {\n                \"available\": True,\n                \"genres\": [\n                    \"Horror\",\n                    \"Short Stories\",\n                    \"Mystery\"\n                ]\n            })\n\n    Parameters:\n        ISBN (str): The ISBN of the book to update.\n        new_book (dict): A dictionary containing the updated book information.\n        verbose (bool): Whether to print verbose output. Defaults to False.\n\n    Returns:\n        bool: True if the book was successfully updated, False otherwise.\n    \"\"\"\n    try:\n        # Open connection to the database\n        db = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n        if verbose:\n            logger.info(\"Database connection opened.\")\n\n        condition = {\"ISBN\": ISBN}\n        new_values = {}\n\n        latest_ISBN = ISBN\n\n        for key in new_book.keys():\n            if key in [\"ISBN\", \"title\", \"description\", \"available\"]:\n                new_values[key] = new_book[key]\n            if key == \"ISBN\":\n                latest_ISBN = new_book[\"ISBN\"]\n            if key == \"description\":\n                new_values[\"embedding\"] = get_embedding(new_book[\"description\"]).tolist()\n\n        db.update_records(\"book\", new_values, condition, verbose=verbose)\n        if verbose:\n            logger.info(\"Book table updated.\")\n\n        ISBN = latest_ISBN\n\n        # Get the tables\n        book_author = db.get_table(\"bookauthor\", conditions={\"isbn\": ISBN}, verbose=verbose)\n        book_genre = db.get_table(\"bookgenre\", conditions={\"isbn\": ISBN}, verbose=verbose)\n\n        # Add author(s) to the author table if doesn't exist\n        if \"authors\" in new_book:\n            if verbose:\n                logger.info(\"Authors to be updated.\")\n\n            authors = new_book[\"authors\"]\n            new_author_ids = set(_get_or_add_authors(db, authors, verbose=verbose))\n            current_author_ids = set(book_author[book_author[\"isbn\"] == ISBN][\"author_id\"].tolist())\n\n            removed_authors = current_author_ids - new_author_ids\n            added_authors = new_author_ids - current_author_ids\n\n            db.remove_records(\"bookauthor\", [{\"isbn\": ISBN, \"author_id\": int(removed_author)} for removed_author in removed_authors], verbose=verbose)\n            db.insert_records(\"bookauthor\", [{\"isbn\": ISBN, \"author_id\": int(added_author)} for added_author in added_authors], verbose=verbose)\n\n            if verbose:\n                logger.info(\"Author table updated.\")\n        else:\n            if verbose:\n                logger.info(\"No authors to be updated.\")\n\n        # Add genres to the genres table if doesn't exist\n        if \"genres\" in new_book:\n            if verbose:\n                logger.info(\"Genres to be updated.\")\n\n            genres = new_book[\"genres\"]    \n            new_genre_ids = set(_get_or_add_genres(db, genres, verbose=verbose))\n            current_genre_ids = set(book_genre[book_genre[\"isbn\"] == ISBN][\"genre_id\"].tolist())\n\n            removed_genres = current_genre_ids - new_genre_ids\n            added_genres = new_genre_ids - current_genre_ids\n\n            db.remove_records(\"bookgenre\", [{\"isbn\": ISBN, \"genre_id\": int(removed_genre)} for removed_genre in removed_genres], verbose=verbose)\n            db.insert_records(\"bookgenre\", [{\"isbn\": ISBN, \"genre_id\": int(added_genre)} for added_genre in added_genres], verbose=verbose)\n\n            if verbose:\n                logger.info(\"Genre table updated.\")\n        else:\n            if verbose:\n                logger.info(\"No genres to be updated.\")\n\n        return True\n    except:\n        return False\n</code></pre>"},{"location":"sql_interactions/#loading-data-into-the-database","title":"Loading Data Into the Database","text":""},{"location":"sql_interactions/#kitab.db.get_data","title":"<code>kitab.db.get_data</code>","text":""},{"location":"sql_interactions/#kitab.db.get_data.get_full_data","title":"<code>get_full_data(folder_path='data', verbose=False)</code>","text":"<p>Retrieves and combines data from multiple CSV files and corresponding pickle files.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.get_data import get_full_data\n&gt;&gt;&gt; get_full_data(folder_path=\"data\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>The path to the directory containing the CSV and pickle files.</p> <code>'data'</code> <code>verbose</code> <code>bool</code> <p>Whether to display logs. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the combined data with an additional 'embedding' column.</p> Source code in <code>kitab\\db\\get_data.py</code> <pre><code>def get_full_data(folder_path: str = \"data\", verbose: bool = False) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieves and combines data from multiple CSV files and corresponding pickle files.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.get_data import get_full_data\n        &gt;&gt;&gt; get_full_data(folder_path=\"data\")\n\n    Parameters:\n        folder_path (str): The path to the directory containing the CSV and pickle files.\n        verbose (bool): Whether to display logs. Default is False.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the combined data with an additional 'embedding' column.\n    \"\"\"\n    data_paths = sorted(glob(f\"{folder_path}/*.csv\"))\n    emb_paths = sorted(glob(f\"{folder_path}/*.pkl\"))\n\n    if len(data_paths) == 0:\n        raise Exception(\"No CSV files found in the specified folder.\")\n    elif len(emb_paths) == 0:\n        raise Exception(\"No PKL files found in the specified folder.\")\n    elif len(data_paths) != len(emb_paths):\n        raise Exception(\"The number of CSV and PKL files do not match.\")\n\n    if verbose:\n        logger.info(\"Data and embeddings found successfully.\")\n\n    datas = [pd.read_csv(data_path) for data_path in data_paths]\n    embs = []\n\n    for emb_path in emb_paths:\n        with open(emb_path, \"rb\") as f:\n            emb = pickle.load(f)\n        embs.append(emb)\n\n    df = pd.concat(datas).reset_index(drop=True)\n    df[\"embedding\"] = np.concatenate(embs).tolist()\n\n    if verbose:\n        logger.info(\"Data and embeddings combined successfully.\")\n\n    return df\n</code></pre>"},{"location":"sql_interactions/#kitab.db.get_data.load_data","title":"<code>load_data(folder_path='data', verbose=False)</code>","text":"<p>Load data from a specified folder path and insert it into the database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kitab.db.get_data import load_data\n&gt;&gt;&gt; load_data(folder_path=\"data\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>The path to the folder containing the data files. Default is \"data\".</p> <code>'data'</code> <code>verbose</code> <code>bool</code> <p>Whether to display logs. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kitab\\db\\get_data.py</code> <pre><code>def load_data(folder_path: str = \"data\", verbose: bool = False) -&gt; None:\n    \"\"\"\n    Load data from a specified folder path and insert it into the database.\n\n    Examples:\n        &gt;&gt;&gt; from kitab.db.get_data import load_data\n        &gt;&gt;&gt; load_data(folder_path=\"data\")\n\n    Parameters:\n        folder_path (str): The path to the folder containing the data files. Default is \"data\".\n        verbose (bool): Whether to display logs. Default is False.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        # Getting the full data\n        data = get_full_data(folder_path, verbose=verbose)\n\n        data.fillna({\"genre\": \"\"}, inplace=True)\n        data = data[REQUIRED_COLUMNS + [\"embedding\", \"available\"]]\n\n        data.dropna(subset = [\"isbn\", \"description\"], inplace=True)\n\n        book_table = data[[\"isbn\", \"title\", \"description\", \"embedding\", \"available\"]]\n\n        if verbose:\n            logger.info(\"Data loaded successfully.\")\n\n        def split_and_filter(cell):\n            if cell:\n                genres = cell.split(\",\")\n                return [g.strip() for g in genres if g]\n            else:\n                return []\n\n        authors = data[\"author\"].apply(lambda x: split_and_filter(x))\n        data[\"author\"] = authors\n        unique_authors = authors.explode().dropna().unique()\n        author_table = pd.DataFrame({\"author_id\": range(1, len(unique_authors)+1), \"full_name\": unique_authors})\n\n        if verbose:\n            logger.info(\"Authors extracted successfully.\")\n\n        books_with_authors = data[data['author'].map(lambda d: len(d)) &gt; 0]\n        book_author = books_with_authors.explode(\"author\")[[\"author\", \"isbn\"]]\n        book_author = pd.merge(book_author, author_table, how='left', left_on='author', right_on='full_name')[[\"isbn\", \"author_id\"]]\n        # book_author.rename(columns={\"isbn\":\"ISBN\"}, inplace=True)\n        book_author.drop_duplicates(inplace=True)\n        book_author.reset_index(drop=True, inplace=True)\n        book_author[\"author_id\"] = book_author[\"author_id\"].astype(int)\n\n        if verbose:\n            logger.info(\"Book-Author mapping created successfully.\")\n\n        genres = data[\"genre\"].apply(lambda x: split_and_filter(x))\n        data[\"genre\"] = genres\n        unique_genres = genres.explode().dropna().unique()\n        genre_table = pd.DataFrame({\"genre_id\": range(1, len(unique_genres)+1), \"genre\": unique_genres})\n\n        if verbose:\n            logger.info(\"Genres extracted successfully.\")\n\n        books_with_genres = data[data['genre'].map(lambda d: len(d)) &gt; 0]\n        book_genre = books_with_genres.explode(\"genre\")[[\"genre\", \"isbn\"]]\n        book_genre[\"genre\"] = book_genre[\"genre\"].str.strip()\n        book_genre = pd.merge(book_genre, genre_table, how='left', left_on='genre', right_on='genre')[[\"isbn\", \"genre_id\"]]\n        # book_genre.rename(columns={\"isbn\":\"ISBN\"}, inplace=True)\n        book_genre.drop_duplicates(inplace=True)\n        book_genre.reset_index(drop=True, inplace=True)\n        book_genre[\"genre_id\"] = book_genre[\"genre_id\"].astype(int)\n\n        if verbose:\n            logger.info(\"Book-Genre mapping created successfully.\")\n\n        # Establish connection with the database\n        sql_handler = SqlHandler(DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)\n\n        # Create tables in the DB\n        for command in COMMANDS:\n            sql_handler.cursor.execute(command)\n\n        if verbose:\n            logger.info(\"Tables created successfully.\")\n\n        # Inserting data\n        # Book table\n        sql_handler.insert_many(book_table, \"book\", verbose=verbose)\n\n        if verbose:\n            logger.info(\"Book data inserted successfully.\")\n\n        # Author table\n        sql_handler.insert_many(author_table, \"author\", verbose=verbose)\n\n        if verbose:\n            logger.info(\"Author data inserted successfully.\")\n\n        # Genre table\n        sql_handler.insert_many(genre_table, \"genre\", verbose=verbose)\n\n        if verbose:\n            logger.info(\"Genre data inserted successfully.\")\n\n        # BookAuthor table\n        sql_handler.insert_many(book_author, \"bookauthor\", verbose=verbose)\n\n        if verbose:\n            logger.info(\"Book-Author mapping inserted successfully.\")\n\n        # BookGenre table\n        sql_handler.insert_many(book_genre, \"bookgenre\", verbose=verbose)\n\n        if verbose:\n            logger.info(\"Book-Genre mapping inserted successfully.\")\n\n        # Close the connection\n        sql_handler.close_cnxn(verbose=verbose)\n\n    except psycopg2.Error as e:\n        logger.error(\"Unable to connect to the PostgreSQL server.\")\n</code></pre>"}]}